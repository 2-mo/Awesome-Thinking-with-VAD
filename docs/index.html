<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracing Video Anomaly Understanding</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- SnapDOM (DOM to image) -->
    <script src="https://cdn.jsdelivr.net/npm/@zumer/snapdom@2.0.2/dist/snapdom.min.js"></script>
    <!-- Elegant Handwriting Fonts: Added Italianno -->
    <link href="https://fonts.googleapis.com/css2?family=Italianno&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --spine-color: rgba(255, 255, 255, 0.22);
            /* 分类配色 - 柔和发光 */
            --llm-color: #e5f0db;
            --vlm-color: #ddd2e9;
            --data-color: #e0ebf6;
            --llm-accent: #bef264;
            --vlm-accent: #c084fc;
            --data-accent: #7dd3fc;
            /* 默认深色模式配置 */
            --bg-color: #0b1220;
            --text-main: #f8fafc;
            --text-muted: #cbd5e1;
            --card-bg: rgba(15, 23, 42, 0.85);
            --badge-border: rgba(255,255,255,0.14);
            --llm-glow: rgba(190, 242, 100, 0.25);
            --vlm-glow: rgba(192, 132, 252, 0.25);
            --data-glow: rgba(125, 211, 252, 0.25);
            --img-filter: brightness(0.82) contrast(1.05);
            --modal-shadow: 0 0 50px rgba(0,0,0,0.8);
            --panorama-pt: 120px;
            --panorama-pb: 60px;
            --panorama-pl: 6vw;
            --panorama-pr: 0px;
        }

        .light-theme {
            --bg-color: #f6f7f9;
            --text-main: #1b2430;
            --text-muted: #4b5563;
            --card-bg: rgba(255, 255, 255, 0.96);
            --spine-color: rgba(15, 23, 42, 0.12);
            --llm-glow: rgba(15, 76, 129, 0.12);
            --vlm-glow: rgba(90, 65, 140, 0.12);
            --data-glow: rgba(14, 116, 144, 0.12);
            --badge-border: rgba(15, 23, 42, 0.12);
            --img-filter: none;
            --modal-shadow: 0 24px 48px -16px rgba(15, 23, 42, 0.18);
        }
        
        body { 
            font-family: 'Times New Roman', Times, serif !important;
            background-color: var(--bg-color);
            color: var(--text-main);
            overflow: hidden;
            transition: background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1), color 0.6s ease;
        }

        .atlas-bg-base {
            position: fixed;
            inset: 0;
            z-index: -40;
            background: var(--bg-color);
            transition: background 0.6s ease;
        }

        .bing-bg {
            position: fixed;
            inset: 0;
            background-image: url('https://bing.biturl.top/?resolution=1920&format=image&index=0&mkt=zh-CN');
            background-size: cover;
            background-position: center;
            opacity: 0.08;
            filter: grayscale(0.7) brightness(0.5) contrast(1.05);
            z-index: -30;
            pointer-events: none;
            transition: filter 0.6s ease, opacity 0.6s ease;
        }
        .light-theme .bing-bg {
            opacity: 0;
            filter: none;
        }

        .light-theme #bg-canvas,
        .light-theme #click-canvas {
            display: none;
        }

        #bg-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: -20;
            pointer-events: none;
        }

        #click-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: -15;
            pointer-events: none;
        }

        .panorama-viewport {
            cursor: grab;
            user-select: none;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-x;
            padding-top: var(--panorama-pt) !important;
            padding-bottom: var(--panorama-pb) !important;
            padding-left: var(--panorama-pl) !important;
            padding-right: var(--panorama-pr) !important;
        }

        .stacked-view {
            display: none;
        }

        .stacked-item {
            break-inside: avoid;
            display: inline-block;
            width: 100%;
            margin-bottom: 10px;
        }

        .top-bar-landscape {
            display: none;
            pointer-events: none;
        }

        .legend-bar {
            display: grid;
            grid-auto-flow: column;
            grid-auto-columns: max-content;
            justify-content: center;
            align-items: center;
            gap: 32px;
        }

        .export-freeze * {
            animation: none !important;
            transition: none !important;
        }

        .export-capture .top-left-bar,
        .export-capture .top-right-bar,
        .export-capture .year-nav {
            display: none !important;
        }

        .export-capture {
            background-color: var(--bg-color) !important;
            background-image: none !important;
        }

        .export-capture #bg-canvas,
        .export-capture #click-canvas {
            display: none !important;
        }

        .export-capture .panorama-viewport {
            overflow: visible !important;
        }

        .export-capture .title-bar,
        .export-capture .legend-bar {
            position: absolute !important;
            left: 0 !important;
            right: 0 !important;
        }

        .export-capture .atlas-handwritten-title {
            white-space: nowrap !important;
        }

        .copyright-note {
            font-size: 10px;
            letter-spacing: 0.08em;
            opacity: 0.5;
            white-space: nowrap;
        }

        .export-capture .copyright-note {
            position: absolute !important;
            right: 24px !important;
            bottom: 12px !important;
        }

        .export-svg .truncate {
            overflow: visible !important;
            text-overflow: clip !important;
            white-space: normal !important;
        }

        .export-bg {
            position: absolute;
            inset: 0;
            background: var(--bg-color);
            z-index: -35;
            pointer-events: none;
        }

        @media print {
            @page {
                size: auto;
                margin: 0mm;
            }
            body {
                background-color: white !important;
                color: black !important;
                overflow: visible !important;
                height: auto !important;
                width: auto !important;
            }
            /* Hide UI elements */
            .top-left-bar, .top-right-bar, .fixed, 
            .theme-toggle-btn, .export-btn, .nav-btn,
            #bg-canvas, #click-canvas, .bing-bg {
                display: none !important;
            }
            
            /* Reset layout constraints for full content exposure */
            #root, .h-screen, .panorama-viewport {
                height: auto !important;
                width: auto !important;
                position: static !important;
                overflow: visible !important;
                display: block !important;
            }
            
            /* Ensure the timeline container expands fully */
            .inline-flex {
                display: flex !important;
                flex-wrap: wrap !important; /* Wrap for vertical printing */
                width: 100% !important;
                min-width: 0 !important;
                padding: 0 !important;
                transform: none !important;
                left: 0 !important;
            }

            /* Adjust card styling for print ink */
            .card-glass {
                background: white !important;
                border: 1px solid #ccc !important;
                box-shadow: none !important;
                break-inside: avoid;
                color: black !important;
            }
            .text-slate-100, .text-slate-800 {
                color: black !important;
            }

            /* Convert horizontal layout to vertical flow for printable pages */
            /* This transforms the timeline from a long strip to a list of years/columns */
            .inline-flex > div {
                 border-right: none !important;
                 border-bottom: 2px solid #eee;
                 margin-bottom: 20px;
                 padding-bottom: 20px;
            }
        }
        .panorama-viewport:active { cursor: grabbing; }
        .no-scrollbar::-webkit-scrollbar { display: none; }

        .timeline-spine {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--spine-color) 5%, var(--spine-color) 95%, transparent);
            position: absolute;
            top: 65%; left: 0; width: 100%;
            z-index: 0;
            transition: background 0.6s ease;
        }

        /* Updated Title Styling with Italianno */
        .atlas-handwritten-title {
            font-family: 'Italianno', cursive;
            font-size: 5.5rem;
            font-weight: 400;
            color: var(--text-main);
            opacity: 0.95;
            letter-spacing: 0.03em;
            line-height: 1;
            transition: color 0.6s ease;
        }
        .light-theme .atlas-handwritten-title {
            color: #1e293b;
        }

        .badge-tab-tech-cut {
            position: absolute;
            bottom: -1px; right: -1px;
            padding: 2px 10px 1px 12px;
            z-index: 30;
            clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
            display: flex; align-items: center; justify-content: center;
        }

        .badge-text-flat {
            font-size: 9px; font-weight: 900; 
            text-transform: uppercase; font-family: sans-serif !important;
            line-height: 1;
            letter-spacing: 0.06em;
        }

        .card-glass {
            background-color: var(--card-bg);
            backdrop-filter: blur(10px) saturate(1.15);
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            border: 1px solid rgba(255,255,255,0.12);
            position: relative;
            overflow: hidden;
        }
        .light-theme .card-glass {
            border: 1px solid rgba(0,0,0,0.08);
            background-color: var(--card-bg);
            box-shadow: none;
        }

        .card-glass::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(
                circle 180px at var(--glow-x, -100px) var(--glow-y, -100px),
                rgba(255, 255, 255, 0.25),
                rgba(255, 255, 255, 0.08) 40%,
                transparent 70%
            );
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 50;
            mix-blend-mode: screen;
        }
        .light-theme .card-glass::before {
            background: none;
            opacity: 0 !important;
        }
        .light-theme .card-glass:hover::before {
            opacity: 0 !important;
        }
        .card-glass:hover::before {
            opacity: 1;
        }

        /* Remove old ::after glow if any conflicts, keep the existing ::after for accent or remove it */
        .card-glass::after {
            content: none;
        }

        .card-glass:hover {
            box-shadow: 
                0 20px 40px -15px rgba(0, 0, 0, 0.3),
                0 0 25px -2px var(--shadow-color); 
            transform: translateY(-8px); 
            border-color: rgba(255,255,255,0.15);
        }
        .light-theme .card-glass:hover {
            box-shadow: 0 12px 28px -12px rgba(15, 23, 42, 0.18), 0 0 18px -6px var(--shadow-color);
            transform: translateY(-6px);
            border-color: rgba(15, 23, 42, 0.08);
        }

        img {
            filter: var(--img-filter);
            transition: filter 0.6s ease;
        }

        .arxiv-icon {
            transition: transform 0.2s ease;
            transform-origin: center;
        }

        a:hover .arxiv-icon {
            transform: scale(1.15);
        }

        /* Top Action Bar Placement */
        .top-left-bar {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
        }

        .top-right-bar {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
        }

        .theme-toggle-btn {
            width: 32px;
            height: 32px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .light-theme .theme-toggle-btn { background: rgba(15, 23, 42, 0.04); border-color: rgba(15, 23, 42, 0.08); color: #475569; }
        .theme-toggle-btn:hover { background: rgba(255,255,255,0.1); color: #fff; transform: scale(1.05); }
        .light-theme .theme-toggle-btn:hover { background: rgba(15, 23, 42, 0.08); color: #0f172a; }

        .star-tooltip {
            position: absolute;
            right: calc(100% + 14px);
            background: #0f172a;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
            padding: 6px 14px;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            opacity: 0;
            transform: translateX(10px);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            white-space: nowrap;
            font-family: sans-serif;
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .light-theme .star-tooltip { background: #f8fafc; color: #0f172a; border-color: rgba(15, 23, 42, 0.08); }
        .github-link-group:hover .star-tooltip { opacity: 1; transform: translateX(0); }

        .bg-year-watermark {
            font-size: 26vw; font-weight: 900; font-family: 'Times New Roman', serif;
            font-style: italic; color: var(--text-main); opacity: 0.035; 
            pointer-events: none; white-space: nowrap; transition: opacity 0.6s ease, transform 0.6s ease;
        }
        .light-theme .bg-year-watermark { opacity: 0.008; }
        
        .nav-btn {
            background: rgba(255,255,255,0.03); backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.08); color: var(--text-muted);
            font-size: 12px; font-weight: 900; text-transform: uppercase;
            padding: 5px 18px; border-radius: 9999px; transition: all 0.3s ease;
        }
        .light-theme .nav-btn { background: #f8fafc; border: 1px solid rgba(15, 23, 42, 0.08); color: #334155; }
        .light-theme .nav-btn:hover { background: #eef2f7; border-color: rgba(15, 23, 42, 0.14); color: #0f172a; }
        .nav-btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.2); color: #fff; transform: translateY(-1px); }

        .export-btn {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-muted);
            font-size: 11px; font-weight: 900; text-transform: uppercase;
            padding: 4px 10px; border-radius: 8px; transition: all 0.25s ease;
        }
        .export-btn:hover {
            background: rgba(255,255,255,0.12);
            color: #fff;
            transform: translateY(-1px);
        }
        .export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .light-theme .export-btn {
            background: rgba(15, 23, 42, 0.04);
            border-color: rgba(15, 23, 42, 0.08);
            color: #334155;
        }
        .light-theme .export-btn:hover {
            background: rgba(15, 23, 42, 0.08);
            color: #0f172a;
        }


        /* Pop-up design */
        .modal-container {
            background-color: var(--card-bg); backdrop-filter: blur(16px);
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: var(--modal-shadow);
        }
        
        .modal-close-trigger {
            position: absolute;
            top: 28px;
            right: 28px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            color: #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 120;
        }
        .light-theme .modal-close-trigger {
            background: rgba(15, 23, 42, 0.04);
            border-color: rgba(15, 23, 42, 0.08);
            color: #0f172a;
        }
        .modal-close-trigger:hover {
            background: rgba(239, 68, 68, 0.8);
            border-color: transparent;
            color: #fff;
            transform: rotate(90deg) scale(1.1);
        }

        @media (max-width: 1024px) {
            :root {
                --panorama-pt: 150px;
            }
            .top-left-bar {
                top: 12px;
                left: 16px;
            }
            .top-right-bar {
                top: 12px;
                right: 16px;
                gap: 10px;
            }
            .top-right-bar .export-btn {
                padding: 5px 12px;
                font-size: 12px;
            }
            .top-right-bar svg {
                width: 26px;
                height: 26px;
            }
            .top-left-bar .theme-toggle-btn {
                width: 32px;
                height: 32px;
                border-radius: 10px;
            }
            .atlas-handwritten-title {
                font-size: 4.2rem;
                line-height: 0.9;
                padding: 0 20px;
                text-align: center;
            }
            .title-bar {
                top: 32px;
            }
            .year-nav {
                top: 118px;
            }
            .nav-btn {
                padding: 6px 16px;
                font-size: 12px;
            }
        }

        @media (max-width: 768px) {
            :root {
                --panorama-pt: 170px;
            }
            .atlas-handwritten-title {
                font-size: 4rem;
            }
            .year-nav {
                top: 148px;
            }
            .nav-btn {
                padding: 4px 12px;
                font-size: 11px;
            }
            .card-container .card-glass {
                width: 175px !important;
            }
            .bg-year-watermark {
                font-size: 22vw;
            }
        }

        @media (max-width: 640px) {
            :root {
                --panorama-pt: 200px;
                --panorama-pb: 110px;
                --panorama-pl: 4vw;
                --panorama-pr: 0px;
            }
            .top-left-bar {
                top: 10px;
                left: 12px;
            }
            .top-right-bar {
                top: 10px;
                right: 12px;
                flex-direction: row;
                align-items: center;
                gap: 6px;
                flex-wrap: nowrap;
            }
            .top-right-bar .mr-3 {
                margin-right: 0 !important;
            }
            .top-right-bar .export-btn {
                padding: 3px 7px;
                font-size: 10px;
            }
            .top-right-bar svg {
                width: 22px;
                height: 22px;
            }
            .top-left-bar .theme-toggle-btn {
                width: 26px;
                height: 26px;
                border-radius: 8px;
            }
            .atlas-handwritten-title {
                font-size: 3.2rem;
                line-height: 0.95;
                padding: 0 14px;
                text-align: center;
            }
            .title-bar {
                top: 52px;
            }
            .year-nav {
                top: 168px;
                gap: 6px;
                padding: 0 12px;
                flex-wrap: wrap;
            }
            .nav-btn {
                font-size: 10px;
                padding: 4px 10px;
                letter-spacing: 0.08em;
            }
            .inline-flex {
                padding-left: 28vw !important;
            }
            .card-container .card-glass {
                width: 160px !important;
            }
            .card-container .card-glass h4 {
                font-size: 11px !important;
            }
            .card-container .card-glass p {
                font-size: 9px !important;
            }
            .bg-year-watermark {
                font-size: 18vw;
                opacity: 0.025;
            }
            .legend-bar {
                display: grid !important;
                grid-template-columns: repeat(2, minmax(0, 1fr));
                column-gap: 8px;
                row-gap: 4px;
                padding: 0 10px;
                bottom: 8px;
                justify-items: center;
                align-items: center;
            }
            .legend-bar > div {
                justify-content: center;
            }
            .legend-bar span {
                font-size: 9px !important;
                letter-spacing: 0.2em;
            }
            .modal-container .p-10 {
                padding: 22px !important;
            }
            .modal-container h3 {
                font-size: 20px !important;
            }
            .modal-container .grid {
                grid-template-columns: 1fr !important;
            }
            .copyright-note {
                font-size: 9px;
            }
        }

        @media (max-height: 600px) and (orientation: landscape) and (pointer: coarse) {
            :root {
                --panorama-pt: 104px;
                --panorama-pl: 12px;
                --panorama-pr: 12px;
                --stacked-col-width: 190px;
                --stacked-row-size: max-content;
                --stacked-gap: 6px;
                --legend-height: 26px;
                --legend-offset: 0px;
                --legend-clearance: 44px;
                --panorama-pb: calc(var(--legend-height) + var(--legend-offset) + var(--legend-clearance));
                --stacked-height: calc(100vh - var(--panorama-pt) - var(--panorama-pb));
            }
            .top-left-bar,
            .top-right-bar {
                display: none !important;
            }
            .top-bar-landscape {
                display: flex;
                position: fixed;
                top: 8px;
                left: 12px;
                right: 12px;
                align-items: center;
                justify-content: space-between;
                gap: 10px;
                z-index: 100;
                pointer-events: none;
            }
            .top-bar-landscape .bar-actions {
                display: flex;
                align-items: center;
                gap: 6px;
                pointer-events: auto;
            }
            .top-bar-landscape .theme-toggle-btn {
                width: 28px;
                height: 28px;
                border-radius: 8px;
            }
            .top-bar-landscape .export-btn {
                padding: 3px 8px;
                font-size: 10px;
            }
            .top-bar-landscape svg {
                width: 22px;
                height: 22px;
            }
            .top-bar-landscape .atlas-handwritten-title {
                font-size: 2.2rem;
                line-height: 0.9;
                padding: 0;
                text-align: left;
                white-space: nowrap;
            }
            .title-bar {
                display: none !important;
            }
            .year-nav {
                display: none !important;
            }
            .panorama-viewport {
                overflow-x: auto !important;
                overflow-y: hidden !important;
                touch-action: pan-x;
            }
            .timeline-view {
                display: none !important;
            }
            .stacked-view {
                display: inline-grid;
                grid-auto-flow: column;
                grid-auto-columns: var(--stacked-col-width);
                grid-template-rows: repeat(3, var(--stacked-row-size));
                gap: var(--stacked-gap);
                padding: 0 2px 6px;
                width: max-content;
                height: var(--stacked-height);
                align-content: end;
            }
            .stacked-view .card-container {
                width: 100%;
            }
            .stacked-view .card-glass {
                width: 100% !important;
            }
            .stacked-item {
                display: block;
                margin-bottom: 0;
            }
            .stacked-view .node-connector {
                display: none;
            }
            .timeline-spine,
            .timeline-axis,
            .bg-year-watermark {
                display: none !important;
            }
            .timeline-column {
                grid-template-rows: 1fr 0px 1fr !important;
            }
            .legend-bar {
                bottom: var(--legend-offset);
                gap: 8px;
                height: var(--legend-height);
            }
            .legend-bar span {
                font-size: 8px !important;
                letter-spacing: 0.16em;
            }
            .copyright-note {
                display: block;
                font-size: 8px;
            }
        }
    </style>
</head>
<body class="selection:bg-indigo-900/30">
    <div class="atlas-bg-base"></div>
    <div class="bing-bg"></div>
    <canvas id="bg-canvas"></canvas>
    <canvas id="click-canvas"></canvas>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, Fragment, memo, useLayoutEffect } = React;

        const GITHUB_LINK = "https://github.com/2-mo/Awesome-Thinking-with-VAD";
        const CONF_THEMES = {
            "CVPR": "#60a5fa", "AAAI": "#f87171", "ICCV": "#818cf8", 
            "ECCV": "#fbbf24", "ACM MM": "#c084fc", "NeurIPS": "#34d399", 
            "ICML": "#6366f1", "DEFAULT": "#94a3b8"
        };

        const ACCENTS = {
            llm: { label: "Reasoning (LLM)", accent: "bg-[#c4f08a]", color: "#eef7e7", highlight: "#c4f08a", glow: "rgba(196, 240, 138, 0.28)" }, 
            clip: { label: "Multimodal (VLM)", accent: "bg-[#c49aff]", color: "#ede6f7", highlight: "#c49aff", glow: "rgba(196, 154, 255, 0.28)" }, 
            dataset: { label: "Benchmark", accent: "bg-[#7ec7ff]", color: "#e9f4fb", highlight: "#7ec7ff", glow: "rgba(126, 199, 255, 0.28)" }   
        };

        const CONF_MONTHS = { "AAAI": 2, "CVPR": 6, "ICML": 7, "ECCV": 10, "ACM MM": 10, "ICCV": 10, "NeurIPS": 12 };

        // Fully reconstructed data based on provided image_87bde7.jpg
        const PAPER_DATA = [
    // 2023
    { name: "EVAL", title: "Explainable Video Anomaly Detection via Multi-Grained Reasoning", year: "2023", conf: "CVPR'23", type: "llm", logo: "https://upload.wikimedia.org/wikipedia/commons/4/40/Tsinghua_University_Logo.svg", anno: "Explainable VAD Architecture", arxiv: "https://arxiv.org/abs/2303.11111", github: "https://github.com/2-mo/EVAL" },
    { name: "PZAAR", title: "PZAAR: Contrastive Representation Learning for VAD", year: "2023", conf: "CVPR'23", type: "llm", logo: "https://upload.wikimedia.org/wikipedia/commons/1/13/Peking_University_Logo.svg", anno: "Contrastive Learning", arxiv: "https://arxiv.org/abs/2303.22222", github: "https://github.com/2-mo/PZAAR", badge: "CORE", level: 1 },

    // 2024
    { name: "VadCLIP", title: "VadCLIP: Adapting Vision-Language Models for Weakly Supervised Video Anomaly Detection", year: "2024", conf: "AAAI'24", type: "clip", logo: "https://upload.wikimedia.org/wikipedia/commons/5/50/Emblem_of_CU.png", anno: "Multimodal Foundation", arxiv: "https://arxiv.org/abs/2308.11681", github: "https://github.com/ByZ0e/VadCLIP" },
    { name: "STPrompt", title: "STPrompt: Learning Spatio-Temporal Prompts for Multi-Modal Video Anomaly Detection", year: "2024", conf: "ACM MM'24", type: "clip", anno: "Spatio-Temporal Prompting", arxiv: "https://arxiv.org/abs/2407.15177", github: "https://github.com/SIn-Y/STPrompt" },
    { name: "TDSD", title: "Task-Driven Feature Distillation for Spatio-Temporal Video Anomaly Detection", year: "2024", conf: "ACM MM'24", type: "clip", anno: "Distillation", arxiv: "https://arxiv.org/abs/2407.16279", github: "https://github.com/SIn-Y/TDSD" },
    { name: "LAVAD", title: "Language-Augmented Video Anomaly Detection", year: "2024", conf: "CVPR'24", type: "llm", logo: "https://upload.wikimedia.org/wikipedia/commons/b/b5/National_University_of_Singapore_logo.svg", anno: "Training-free", arxiv: "https://arxiv.org/abs/2403.16118", github: "https://github.com/Xv-Sheng/LAVAD", badge: "HOT", level: 1, badgeColor: "#be123c" },
    { name: "PE-MIL", title: "Prompt-Enhanced Multiple Instance Learning for Weakly Supervised Video Anomaly Detection", year: "2024", conf: "CVPR'24", type: "llm", anno: "Prompt-Enhanced", arxiv: "https://arxiv.org/abs/2403.15949", github: "https://github.com/Mzero-Z/PE-MIL" },
    { name: "TPWNG", title: "Temporal Preference Weakly-supervised Network with Global-local Guidance for Video Anomaly Detection", year: "2024", conf: "CVPR'24", type: "llm", anno: "Weakly Supervised", arxiv: "https://arxiv.org/abs/2404.14818", github: "https://github.com/Hust-Wp/TPWNG" },
    { name: "MULDE", title: "MULDE: Multi-teacher Knowledge Distillation for Video Anomaly Detection", year: "2024", conf: "CVPR'24", type: "llm", anno: "Multi-Teacher Distillation", arxiv: "https://arxiv.org/abs/2403.04543", github: "https://github.com/SIn-Y/MULDE" },
    { name: "CUVA", title: "CUVA: A Causal Inference Benchmark for Visual Anomaly Analysis", year: "2024", conf: "CVPR'24", type: "dataset", logo: "https://upload.wikimedia.org/wikipedia/commons/5/50/Emblem_of_CU.png", anno: "Causation", arxiv: "https://arxiv.org/abs/2403.18216", github: "https://github.com/ByZ0e/CUVA" },
    { name: "PhyAD", title: "PhyAD: Physics-Grounded Video Anomaly Detection", year: "2024", conf: "CVPR'24", type: "dataset", anno: "Physics-Grounded", arxiv: "https://arxiv.org/abs/2404.01569", github: "https://github.com/SIn-Y/PhyAD" },
    { name: "AnomalyRuler", title: "AnomalyRuler: Reasoning-based Framework for Video Anomaly Detection", year: "2024", conf: "ECCV'24", type: "llm", anno: "Ruler-based", arxiv: "https://arxiv.org/abs/2407.12431", github: "https://github.com/JinhaiZhu/AnomalyRuler" },
    { name: "AdaCLIP", title: "AdaCLIP: Adapting CLIP with Hybrid Learnable Prompts for Video Anomaly Detection", year: "2024", conf: "ECCV'24", type: "clip", anno: "Adaptive Alignment", arxiv: "https://arxiv.org/abs/2407.09875", github: "https://github.com/Zheng-Zhiwei/AdaCLIP" },
    { name: "FedVAD", title: "FedVAD: Federated Video Anomaly Detection via Multi-modal Knowledge Distillation", year: "2024", conf: "ECCV'24", type: "llm", anno: "Privacy Protection", arxiv: "https://arxiv.org/abs/2407.04263", github: "https://github.com/SIn-Y/FedVAD" },
    { name: "HawkEye", title: "HawkEye: An Emotion-Aware Benchmark for Video Anomaly Detection", year: "2024", conf: "ACM MM'24", type: "dataset", anno: "Emotion Analysis", arxiv: "https://arxiv.org/abs/2407.14023", github: "https://github.com/ByZ0e/HawkEye" },
    { name: "HAWK", title: "HAWK: A Benchmark for Open-World Video Anomaly Detection", year: "2024", conf: "NeurIPS'24", type: "dataset", anno: "Open-World", arxiv: "https://arxiv.org/abs/2410.12567", github: "https://github.com/Mzero-Z/HAWK" },
    { name: "VarCMP", title: "Variable-Context Modeling and Prediction for Video Anomaly Detection", year: "2024", conf: "AAAI'24", type: "clip", anno: "Variable Context", arxiv: "https://arxiv.org/abs/2312.12836", github: "https://github.com/Hust-Wp/VarCMP" },
    { name: "Fed-WAVAD", title: "Federated Weakly-supervised Video Anomaly Detection with Cross-client Alignment", year: "2024", conf: "AAAI'24", type: "clip", anno: "Federated Learning", arxiv: "https://arxiv.org/abs/2312.13849", github: "https://github.com/SIn-Y/Fed-WAVAD" },

    // 2025
    { name: "VERA", title: "VERA: Verbalized Learning for Video Anomaly Detection", year: "2025", conf: "CVPR'25", type: "llm", anno: "Verbalized Learning", arxiv: "https://arxiv.org/abs/2411.19254" },
    { name: "Holmes-VAU", title: "Holmes-VAU: Towards Multi-Grained Reasoning for Video Anomaly Understanding", year: "2025", conf: "CVPR'25", type: "dataset", anno: "Multi-Grained", arxiv: "https://arxiv.org/abs/2411.18182", github: "https://github.com/ByZ0e/Holmes-VAU" },
    { name: "Ex-VAD", title: "Ex-VAD: Explainable Fine-Grained Video Anomaly Detection", year: "2025", conf: "ICML'25", type: "llm", anno: "Fine-Grained", arxiv: "https://arxiv.org/abs/2412.01234" },
    { name: "VA-GPT", title: "VA-GPT: Visual-Agnostic Generative Pre-trained Transformer for Video Anomaly Detection", year: "2025", conf: "ICCV'25", type: "dataset", anno: "Token Sampling", arxiv: "https://arxiv.org/abs/2411.15678" },
    { name: "HiProbe-VAD", title: "HiProbe: Hierarchical Probing for Multimodal Video Anomaly Detection", year: "2025", conf: "ACM MM'25", type: "llm", anno: "Hierarchical Probing", arxiv: "https://arxiv.org/abs/2412.09876" },
    { name: "EventVAD", title: "EventVAD: Real-time Video Anomaly Detection in Event-based Streams", year: "2025", conf: "ACM MM'25", type: "llm", anno: "Event-based", arxiv: "https://arxiv.org/abs/2412.05432" },
    { name: "Vad-R1", title: "Vad-R1: A Perception-to-Cognition Reasoning Dataset for Video Anomaly Detection", year: "2025", conf: "NeurIPS'25", type: "dataset", logo: "https://upload.wikimedia.org/wikipedia/commons/1/13/Peking_University_Logo.svg", anno: "Perception-to-Cognition", arxiv: "https://arxiv.org/abs/2412.11111", badge: "IMPORTANT", level: 1 },
    { name: "PANDA", title: "PANDA: Prompt Analysis and Reasoning for Video Anomaly Detection", year: "2025", conf: "NeurIPS'25", type: "llm", anno: "Prompt Analysis", arxiv: "https://arxiv.org/abs/2412.22222" },
    { name: "URF-VAA", title: "URF-VAA: Uncertainty Refinement in Video Anomaly Analysis", year: "2025", conf: "NeurIPS'25", type: "llm", anno: "Uncertainty Refinement", arxiv: "https://arxiv.org/abs/2412.33333" },
    { name: "VADTree", title: "VADTree: Hierarchical Detection Tree for Video Anomaly Detection", year: "2025", conf: "NeurIPS'25", type: "llm", anno: "Hierarchical Tree", arxiv: "https://arxiv.org/abs/2412.44444" },
    { name: "MoniTor", title: "MoniTor: A Systematic Paradigm for Monitor-based Video Anomaly Detection", year: "2025", conf: "NeurIPS'25", type: "llm", anno: "Monitor Paradigm", arxiv: "https://arxiv.org/abs/2412.55555" },
    { name: "A2Seek", title: "A2Seek: Drone-view Benchmark and Graph-of-Thought for Video Anomaly Detection", year: "2025", conf: "NeurIPS'25", type: "dataset", anno: "Drone-view & GoT", arxiv: "https://arxiv.org/abs/2412.66666", github: "https://github.com/2-mo/A2Seek"}
];

        // UI Components
        function Icon({ name, size = 16, className = "" }) {
            const icons = {
                Github: <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>,
                Close: <path d="M18 6 6 18M6 6l12 12" strokeWidth="2.5" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round"/>,
                Sun: <path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364-6.364l-.707.707M6.343 17.657l-.707.707m0-12.728l.707.707m11.314 11.314l.707.707M12 8a4 4 0 100 8 4 4 0 000-8z" strokeWidth="2" stroke="currentColor"/>,
                Moon: <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" strokeWidth="2" stroke="currentColor"/>,
                Monitor: <path d="M3 5a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V5zM8 21h8M12 17v4" strokeWidth="2" stroke="currentColor"/>
            };
            return (
                <svg viewBox="0 0 24 24" width={size} height={size} fill={["Github"].includes(name) ? "currentColor" : "none"} stroke={["Close", "Sun", "Moon", "Monitor"].includes(name) ? "currentColor" : "none"} className={className}>
                    {icons[name] || null}
                </svg>
            );
        }

        function BrandIcon({ name, size = 10 }) {
            if (name === "Arxiv") return (
                <div className="flex items-center justify-center shrink-0">
                    <img src="public/base/arxiv-logomark-small.svg" alt="arXiv" className="arxiv-icon" style={{ height: `${Math.max(size - 2, 8)}px` }} />
                </div>
            );
            return null;
        }

        function CuratorBadge({ badge, level, customColor }) {
            if (!badge) return null;
            return (
                <div className="badge-tab-tech-cut" style={{ 
                    backgroundColor: level === 1 ? (customColor || '#801a1a') : 'rgba(255,255,255,0.05)',
                    border: level === 1 ? 'none' : '1px solid var(--badge-border)'
                }}>
                    <span className="badge-text-flat" style={{ color: level === 1 ? 'white' : 'var(--text-muted)' }}>{badge}</span>
                </div>
            );
        }

        const PaperCard = memo(({ paper, onClick, position, isDarkMode }) => {
            const acc = ACCENTS[paper.type] || ACCENTS.llm;
            const confColor = CONF_THEMES[Object.keys(CONF_THEMES).find(k => paper.conf.includes(k))] || CONF_THEMES.DEFAULT;
            const cardRef = useRef(null);

            const handleMouseMove = (e) => {
                if (!cardRef.current) return;
                const rect = cardRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                cardRef.current.style.setProperty('--glow-x', `${x}px`);
                cardRef.current.style.setProperty('--glow-y', `${y}px`);
            };

            const handleMouseLeave = () => {
                if (!cardRef.current) return;
                cardRef.current.style.setProperty('--glow-x', `-100px`);
                cardRef.current.style.setProperty('--glow-y', `-100px`);
            };
            
            return (
                <div className="card-container relative flex flex-col items-center group transition-all" 
                     style={{ "--accent-color": acc.highlight, "--shadow-color": isDarkMode ? acc.glow : 'rgba(0,0,0,0.05)' }}>
                    <div className="node-connector" style={{ height: '8px', bottom: position === 'top' ? '-10px' : 'auto', top: position === 'bottom' ? '-10px' : 'auto' }} />
                    <div 
                        ref={cardRef}
                        onClick={() => onClick(paper)} 
                        onMouseMove={handleMouseMove}
                        onMouseLeave={handleMouseLeave}
                        className="relative w-[190px] card-glass py-2.5 px-3 rounded-sm shadow-sm cursor-pointer animate-node overflow-hidden"
                    >
                        <div className={`accent-bar absolute top-0 left-0 w-[3px] h-full ${acc.accent} z-10 opacity-70`} />
                        <CuratorBadge badge={paper.badge} level={paper.level} customColor={paper.badgeColor} />
                        <div className="card-body flex gap-2 items-center relative z-20">
                            <div className="card-logo w-[28px] h-[28px] shrink-0 flex items-center justify-center group-hover:scale-110 transition-transform duration-500">
                                {paper.logo && paper.logo.startsWith('http') ? (
                                    <img src={paper.logo} className={`max-w-full max-h-full object-contain`} />
                                ) : (
                                    <div className={`w-full h-full ${paper.logo || 'bg-slate-700'} opacity-20 rounded-full`} />
                                )}
                            </div>
                            <div className="flex flex-col min-w-0 flex-1">
                                <div className="card-title-row flex items-center justify-between mb-0.5">
                                    <h4 className={`text-[12px] font-black tracking-tight leading-none truncate pr-1 group-hover:text-blue-400 transition-colors ${isDarkMode ? 'text-slate-100' : 'text-slate-800'}`}>{paper.name}</h4>
                                    <div className="flex items-center gap-1 shrink-0">
                                        <div className="flex items-center gap-1">
                                            {paper.arxiv && (
                                                <a href={paper.arxiv} target="_blank" rel="noopener noreferrer" onClick={(e) => e.stopPropagation()} className="transition-transform hover:scale-110">
                                                    <BrandIcon name="Arxiv" size={14} />
                                                </a>
                                            )}
                                            {paper.github && (
                                                <a href={paper.github} target="_blank" rel="noopener noreferrer" onClick={(e) => e.stopPropagation()} className="transition-transform hover:scale-110">
                                                    <Icon name="Github" size={12} className={isDarkMode ? 'text-white' : 'text-slate-900'} />
                                                </a>
                                            )}
                                        </div>
                                    </div>
                                </div>
                                <p className={`card-anno text-[9.5px] font-medium italic truncate mb-1 leading-tight ${isDarkMode ? 'text-slate-300' : 'text-slate-600'}`}>{paper.anno}</p>
                                <div className="flex items-center"><span className="text-[8px] font-black tracking-tighter uppercase leading-none opacity-70" style={{ color: confColor }}>{paper.conf}</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        });

        function App() {
            const [activeItem, setActiveItem] = useState(null);
            const [theme, setTheme] = useState('system');
            const [resolvedDarkMode, setResolvedDarkMode] = useState(true);
            const [isExporting, setIsExporting] = useState(false);
            const currentYear = new Date().getFullYear();
            const scrollRef = useRef(null);
            const exportRef = useRef(null);
            const timelineRef = useRef(null);
            const getColumnWidth = () => {
                if (typeof window === 'undefined') return 200;
                if (window.innerWidth <= 640) return 170;
                if (window.innerWidth <= 900) return 185;
                return 200;
            };
            const [columnWidth, setColumnWidth] = useState(() => getColumnWidth());


            useEffect(() => {
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                const updateTheme = () => {
                    if (theme === 'dark') setResolvedDarkMode(true);
                    else if (theme === 'light') setResolvedDarkMode(false);
                    else setResolvedDarkMode(mediaQuery.matches);
                };
                updateTheme();
                mediaQuery.addEventListener('change', updateTheme);
                return () => mediaQuery.removeEventListener('change', updateTheme);
            }, [theme]);

            useEffect(() => { document.body.classList.toggle('light-theme', !resolvedDarkMode); }, [resolvedDarkMode]);

            useEffect(() => {
                const onResize = () => setColumnWidth(getColumnWidth());
                window.addEventListener('resize', onResize);
                return () => window.removeEventListener('resize', onResize);
            }, []);

            const handleExportPng = async () => {
                if (isExporting) return;
                const snap = window.snapdom || window.SnapDOM;
                if (!timelineRef.current || !exportRef.current || !scrollRef.current || !snap) {
                    console.error('SnapDOM not available.');
                    return;
                }
                setIsExporting(true);
                document.body.classList.add('export-freeze');
                let prevExportWidth = '';
                let prevExportMinWidth = '';
                let prevExportBg = '';
                let prevScrollerWidth = '';
                let prevScrollerOverflow = '';
                try {
                    const timelineNode = timelineRef.current;
                    const exportNode = exportRef.current;
                    const scroller = scrollRef.current;
                    const scrollerStyle = getComputedStyle(scroller);
                    const padLeft = parseFloat(scrollerStyle.paddingLeft) || 0;
                    const padRight = parseFloat(scrollerStyle.paddingRight) || 0;
                    const fullWidth = timelineNode.scrollWidth + padLeft + padRight;
                    const fullHeight = exportNode.scrollHeight;

                    prevExportWidth = exportNode.style.width;
                    prevExportMinWidth = exportNode.style.minWidth;
                    prevExportBg = exportNode.style.backgroundColor;
                    prevScrollerWidth = scroller.style.width;
                    prevScrollerOverflow = scroller.style.overflow;

                    exportNode.classList.add('export-capture');
                    exportNode.classList.add('export-svg');
                    exportNode.style.width = `${fullWidth}px`;
                    exportNode.style.minWidth = `${fullWidth}px`;
                    exportNode.style.backgroundColor = getComputedStyle(document.body).backgroundColor;
                    scroller.style.width = `${fullWidth}px`;
                    scroller.style.overflow = 'visible';
                    scroller.scrollLeft = 0;

                    const bg = getComputedStyle(document.body).backgroundColor;
                    const capture = await snap(exportNode, {
                        backgroundColor: bg,
                        width: fullWidth,
                        height: fullHeight,
                        scale: 2,
                        embedFonts: true,
                        cache: 'soft',
                        outerTransforms: true,
                        outerShadows: true
                    });
                    await capture.download({
                        format: 'png',
                        filename: 'vad-timeline'
                    });
                } catch (err) {
                    console.error('PNG export failed:', err);
                } finally {
                    const exportNode = exportRef.current;
                    const scroller = scrollRef.current;
                    if (exportNode && scroller) {
                        exportNode.classList.remove('export-capture');
                        exportNode.classList.remove('export-svg');
                        exportNode.style.width = prevExportWidth;
                        exportNode.style.minWidth = prevExportMinWidth;
                        exportNode.style.backgroundColor = prevExportBg;
                        scroller.style.width = prevScrollerWidth;
                        scroller.style.overflow = prevScrollerOverflow;
                    }
                    document.body.classList.remove('export-freeze');
                    setIsExporting(false);
                }
            };

            const handleExportSvg = async () => {
                if (isExporting) return;
                const snap = window.snapdom || window.SnapDOM;
                if (!timelineRef.current || !exportRef.current || !scrollRef.current || !snap) {
                    console.error('SnapDOM not available.');
                    return;
                }
                setIsExporting(true);
                document.body.classList.add('export-freeze');
                let prevExportWidth = '';
                let prevExportMinWidth = '';
                let prevExportBg = '';
                let prevScrollerWidth = '';
                let prevScrollerOverflow = '';
                try {
                    const timelineNode = timelineRef.current;
                    const exportNode = exportRef.current;
                    const scroller = scrollRef.current;
                    const scrollerStyle = getComputedStyle(scroller);
                    const padLeft = parseFloat(scrollerStyle.paddingLeft) || 0;
                    const padRight = parseFloat(scrollerStyle.paddingRight) || 0;
                    const fullWidth = timelineNode.scrollWidth + padLeft + padRight;
                    const fullHeight = exportNode.scrollHeight;

                    prevExportWidth = exportNode.style.width;
                    prevExportMinWidth = exportNode.style.minWidth;
                    prevExportBg = exportNode.style.backgroundColor;
                    prevScrollerWidth = scroller.style.width;
                    prevScrollerOverflow = scroller.style.overflow;

                    exportNode.classList.add('export-capture');
                    exportNode.style.width = `${fullWidth}px`;
                    exportNode.style.minWidth = `${fullWidth}px`;
                    exportNode.style.backgroundColor = getComputedStyle(document.body).backgroundColor;
                    scroller.style.width = `${fullWidth}px`;
                    scroller.style.overflow = 'visible';
                    scroller.scrollLeft = 0;

                    const bg = getComputedStyle(document.body).backgroundColor;
                    const capture = await snap(exportNode, {
                        backgroundColor: bg,
                        width: fullWidth,
                        height: fullHeight,
                        scale: 1,
                        embedFonts: true,
                        cache: 'soft',
                        outerTransforms: true,
                        outerShadows: true
                    });
                    const downloadPromise = capture.download({
                        format: 'svg',
                        filename: 'vad-timeline'
                    });
                    await Promise.race([
                        downloadPromise,
                        new Promise(resolve => setTimeout(resolve, 1200))
                    ]);
                } catch (err) {
                    console.error('SVG export failed:', err);
                } finally {
                    const exportNode = exportRef.current;
                    const scroller = scrollRef.current;
                    if (exportNode && scroller) {
                        exportNode.classList.remove('export-capture');
                        exportNode.style.width = prevExportWidth;
                        exportNode.style.minWidth = prevExportMinWidth;
                        exportNode.style.backgroundColor = prevExportBg;
                        scroller.style.width = prevScrollerWidth;
                        scroller.style.overflow = prevScrollerOverflow;
                    }
                    document.body.classList.remove('export-freeze');
                    setIsExporting(false);
                }
            };

            useLayoutEffect(() => {
                const el = scrollRef.current;
                if (!el) return;
                const scrollToEnd = () => { el.scrollLeft = el.scrollWidth; };
                setTimeout(scrollToEnd, 500);
            }, []);

            // CANVAS LOGIC (UNCHANGED CORE)
            useEffect(() => {
                const canvas = document.getElementById('bg-canvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                let width = canvas.width = window.innerWidth;
                let height = canvas.height = window.innerHeight;
                if (!resolvedDarkMode) {
                    ctx.clearRect(0, 0, width, height);
                    return;
                }
                let raf, last = performance.now();
                const rand = (a, b) => a + Math.random() * (b - a);

                const lines = Array.from({ length: 65 }).map(() => ({
                    x: Math.random() * width, y: Math.random() * height, vx: rand(-1.4, -0.4),
                    len: rand(100, 350), hue: rand(180, 240), opacity: rand(0.05, 0.15)
                }));

                const particles = Array.from({ length: 100 }).map(() => ({
                    x: Math.random() * width, y: Math.random() * height, r: rand(0.5, 2),
                    vx: rand(-0.8, -0.3), vy: rand(-0.1, 0.1), phase: Math.random() * Math.PI * 2, opacity: rand(0.06, 0.2)
                }));

                let hoverSignal = null;
                const onHover = (e) => {
                    const card = e.target.closest('.card-container');
                    if (card) {
                        const rect = card.getBoundingClientRect();
                        hoverSignal = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                    }
                };
                const onLeave = (e) => { if (e.target.closest('.card-container')) hoverSignal = null; };
                document.addEventListener('mouseover', onHover);
                document.addEventListener('mouseout', onLeave);

                const loop = (now) => {
                    const dt = now - last; last = now;
                    ctx.clearRect(0, 0, width, height);
                    ctx.globalCompositeOperation = resolvedDarkMode ? 'lighter' : 'multiply';
                    lines.forEach(s => {
                        s.x += s.vx * dt * 0.05 * (hoverSignal ? 1.5 : 1);
                        if (s.x + s.len < 0) { s.x = width; s.y = Math.random() * height; }
                        ctx.strokeStyle = resolvedDarkMode ? `hsla(${s.hue}, 40%, 60%, ${s.opacity})` : `hsla(${s.hue}, 20%, 30%, ${s.opacity})`;
                        ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x + s.len, s.y); ctx.stroke();
                    });
                    particles.forEach(p => {
                        p.x += p.vx; p.y += p.vy + Math.sin(now * 0.001 + p.phase) * 0.2;
                        if (p.x < -20) p.x = width + 20;
                        ctx.fillStyle = resolvedDarkMode ? `rgba(255, 255, 255, ${p.opacity})` : `rgba(100, 116, 139, ${p.opacity})`;
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
                    });
                    if (hoverSignal) {
                        ctx.strokeStyle = resolvedDarkMode ? 'rgba(255, 255, 255, 0.08)' : 'rgba(44, 74, 112, 0.05)';
                        ctx.lineWidth = 0.6; ctx.beginPath();
                        ctx.moveTo(hoverSignal.x, hoverSignal.y);
                        ctx.quadraticCurveTo(hoverSignal.x - 200, hoverSignal.y - 150, hoverSignal.x - 600, hoverSignal.y + 100);
                        ctx.stroke();
                    }
                    raf = requestAnimationFrame(loop);
                };
                raf = requestAnimationFrame(loop);
                return () => { cancelAnimationFrame(raf); document.removeEventListener('mouseover', onHover); document.removeEventListener('mouseout', onLeave); };
            }, [resolvedDarkMode]);

            useEffect(() => {
                const canvas = document.getElementById('click-canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                let width = canvas.width = window.innerWidth;
                let height = canvas.height = window.innerHeight;
                if (!resolvedDarkMode) {
                    ctx.clearRect(0, 0, width, height);
                    return;
                }

                const burstParticles = [];
                const fwRockets = [];
                const fwParticles = [];
                let raf;

                const burstColors = [
                    "#f9a8d4", "#fbcfe8", "#fecaca", "#fde68a",
                    "#bbf7d0", "#bae6fd", "#c7d2fe", "#e9d5ff"
                ];

                const fwColors = ["#fb7185", "#f59e0b", "#facc15", "#60a5fa", "#34d399", "#a78bfa"];

                const resize = () => {
                    width = canvas.width = window.innerWidth;
                    height = canvas.height = window.innerHeight;
                };

                const spawnBurst = (x, y) => {
                    for (let i = 0; i < 80; i++) {
                        burstParticles.push({
                            x, y,
                            vx: Math.random() * 8 - 4,
                            vy: Math.random() * 8 - 4,
                            color: burstColors[Math.floor(Math.random() * burstColors.length)],
                            radius: 2.6,
                            alpha: 1
                        });
                    }
                };

                const explode = (x, y, color) => {
                    for (let i = 0; i < 70; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 2 + Math.random() * 4.5;
                        fwParticles.push({
                            x, y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            color,
                            radius: 2 + Math.random() * 1.5,
                            alpha: 1
                        });
                    }
                };

                const launchFirework = (x, targetY) => {
                    fwRockets.push({
                        x,
                        y: height + 10,
                        vx: (Math.random() - 0.5) * 1.2,
                        vy: -(6 + Math.random() * 2.5),
                        targetY,
                        color: fwColors[Math.floor(Math.random() * fwColors.length)]
                    });
                };

                const onClick = (e) => {
                    if (resolvedDarkMode) launchFirework(e.clientX, e.clientY);
                    else spawnBurst(e.clientX, e.clientY);
                };

                const draw = () => {
                    ctx.clearRect(0, 0, width, height);

                    if (resolvedDarkMode) {
                        for (let i = fwRockets.length - 1; i >= 0; i--) {
                            const r = fwRockets[i];
                            r.x += r.vx;
                            r.y += r.vy;
                            r.vy += 0.05;
                            if (r.y <= r.targetY) {
                                explode(r.x, r.y, r.color);
                                fwRockets.splice(i, 1);
                                continue;
                            }
                            ctx.globalAlpha = 0.9;
                            ctx.fillStyle = r.color;
                            ctx.beginPath();
                            ctx.arc(r.x, r.y, 2.2, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        for (let i = fwParticles.length - 1; i >= 0; i--) {
                            const p = fwParticles[i];
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += 0.04;
                            p.alpha -= 0.012;
                            if (p.alpha <= 0) {
                                fwParticles.splice(i, 1);
                                continue;
                            }
                            ctx.globalAlpha = p.alpha;
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else {
                        for (let i = burstParticles.length - 1; i >= 0; i--) {
                            const p = burstParticles[i];
                            p.x += p.vx;
                            p.y += p.vy;
                            p.alpha -= 0.012;
                            if (p.alpha <= 0) {
                                burstParticles.splice(i, 1);
                                continue;
                            }
                            ctx.globalAlpha = p.alpha;
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    ctx.globalAlpha = 1;
                    raf = requestAnimationFrame(draw);
                };

                window.addEventListener('resize', resize);
                window.addEventListener('mousedown', onClick);
                raf = requestAnimationFrame(draw);

                return () => {
                    cancelAnimationFrame(raf);
                    window.removeEventListener('resize', resize);
                    window.removeEventListener('mousedown', onClick);
                };
            }, [resolvedDarkMode]);

            const timeline = useMemo(() => {
                const months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
                const columns = [];
                ["2023", "2024", "2025"].forEach(y => {
                    for(let m = 1; m <= 12; m++) {
                        const papers = PAPER_DATA.filter(p => p.year === y && (CONF_MONTHS[Object.keys(CONF_MONTHS).find(k => p.conf.includes(k))] || 6) === m);
                        if (papers.length === 0) continue;
                        const topPapers = papers.filter(p => p.type !== 'dataset');
                        const bottomPapers = papers.filter(p => p.type === 'dataset');
                        const topChunks = []; for(let i=0; i<topPapers.length; i+=5) topChunks.push(topPapers.slice(i, i+5));
                        const bottomChunks = []; for(let i=0; i<bottomPapers.length; i+=5) bottomChunks.push(bottomPapers.slice(i, i+5));
                        const numCols = Math.max(topChunks.length, bottomChunks.length);
                        for(let i = 0; i < numCols; i++) {
                            columns.push({ date: `${months[m-1]} ${y}`, year: y, top: topChunks[i] || [], bottom: bottomChunks[i] || [], isFirstInMonth: i === 0, id: `${y}-${m}-${i}` });
                        }
                    }
                });
                return columns;
            }, []);

            const flatPapers = useMemo(() => {
                const monthOf = (p) => {
                    const key = Object.keys(CONF_MONTHS).find(k => p.conf.includes(k));
                    return key ? CONF_MONTHS[key] : 6;
                };
                return [...PAPER_DATA].sort((a, b) => {
                    const ya = parseInt(a.year, 10);
                    const yb = parseInt(b.year, 10);
                    if (ya !== yb) return ya - yb;
                    const ma = monthOf(a);
                    const mb = monthOf(b);
                    if (ma !== mb) return ma - mb;
                    return a.name.localeCompare(b.name);
                });
            }, []);

            return (
                <div ref={exportRef} className="h-screen w-full flex flex-col relative overflow-hidden">
                    <div className="export-bg" />
                    <div className="top-left-bar">
                        <button onClick={() => setTheme(prev => prev === 'dark' ? 'light' : prev === 'light' ? 'system' : 'dark')} className="theme-toggle-btn">
                            <Icon name={theme === 'dark' ? "Moon" : theme === 'light' ? "Sun" : "Monitor"} size={14} />
                        </button>
                    </div>

                    <div className="top-right-bar gap-2">
                        <div className="flex items-center gap-2">
                            <button className="export-btn" onClick={handleExportPng} disabled={isExporting}>
                                {isExporting ? 'Exporting...' : 'PNG'}
                            </button>
                            <button className="export-btn" onClick={handleExportSvg} disabled={isExporting}>
                                {isExporting ? 'Exporting...' : 'SVG'}
                            </button>
                        </div>
                        <div className="github-link-group relative flex items-center">
                            <div className="star-tooltip">Star to Support Updates ✨</div>
                            <a href={GITHUB_LINK} target="_blank">
                                <Icon name="Github" size={28} className={`${resolvedDarkMode ? 'text-white/60' : 'text-slate-800/60'} transition-all duration-300 hover:rotate-12 hover:scale-110`} />
                            </a>
                        </div>
                    </div>

                    <div className="top-bar-landscape">
                        <h1 className="atlas-handwritten-title">Tracing Video Anomaly Understanding</h1>
                        <div className="bar-actions">
                            <button onClick={() => setTheme(prev => prev === 'dark' ? 'light' : prev === 'light' ? 'system' : 'dark')} className="theme-toggle-btn">
                                <Icon name={theme === 'dark' ? "Moon" : theme === 'light' ? "Sun" : "Monitor"} size={14} />
                            </button>
                            <button className="export-btn" onClick={handleExportPng} disabled={isExporting}>
                                {isExporting ? 'Exporting...' : 'PNG'}
                            </button>
                            <button className="export-btn" onClick={handleExportSvg} disabled={isExporting}>
                                {isExporting ? 'Exporting...' : 'SVG'}
                            </button>
                            <div className="github-link-group relative flex items-center">
                                <a href={GITHUB_LINK} target="_blank">
                                    <Icon name="Github" size={22} className={`${resolvedDarkMode ? 'text-white/60' : 'text-slate-800/60'} transition-all duration-300 hover:rotate-12 hover:scale-110`} />
                                </a>
                            </div>
                        </div>
                    </div>

                    <div className="fixed top-12 title-bar w-full flex flex-col items-center pointer-events-none z-50">
                        <h1 className="atlas-handwritten-title">Tracing Video Anomaly Understanding</h1>
                    </div>

                    <div className="fixed top-44 year-nav w-full flex justify-center gap-4 z-50">
                        {['2023', '2024', '2025'].map(y => (
                            <button key={y} onClick={() => scrollRef.current.scrollLeft = timeline.findIndex(t => t.year === y) * columnWidth + (window.innerWidth/3)} className="nav-btn">{y}</button>
                        ))}
                    </div>

                    <main ref={scrollRef} className="flex-1 panorama-viewport no-scrollbar relative pt-[120px] pb-[60px] pl-[6vw]">
                        <div
                            ref={timelineRef}
                            className="timeline-view inline-flex h-full items-stretch pl-[50vw] pr-0 relative"
                            style={{
                                minWidth: `${timeline.length * columnWidth + 100}px`
                            }}
                        >
                            <div className="timeline-spine" />
                            <div className="absolute inset-0 flex items-center pointer-events-none select-none z-[-10]">
                                {['2023', '2024', '2025'].map(y => {
                                    const firstIdx = timeline.findIndex(t => t.year === y);
                                    if (firstIdx === -1) return null;
                                    const verticalStagger = (parseInt(y) % 2 === 0) ? '40%' : '78%';
                                    return <div key={y} className="absolute flex justify-center items-center" style={{ left: `${firstIdx * columnWidth}px`, width: `${timeline.filter(t => t.year === y).length * columnWidth}px`, height: '100%', top: verticalStagger, transform: 'translateY(-50%)' }}><span className="bg-year-watermark">{y}</span></div>;
                                })}
                            </div>
                            {timeline.map((seg, idx) => (
                                <div key={seg.id} className="timeline-column absolute w-[200px] grid grid-rows-[65fr_20px_35fr] h-full" style={{ left: `${idx * columnWidth}px`, width: `${columnWidth}px` }}>
                                    <div className="flex flex-col-reverse items-center justify-start gap-1.5 pb-2.5 relative z-10 overflow-visible">
                                        {seg.top.map((p, i) => <PaperCard key={i} paper={p} position="top" onClick={() => setActiveItem(p)} isDarkMode={resolvedDarkMode} />)}
                                    </div>
                                    <div className="timeline-axis flex items-center justify-center relative">
                                        {seg.isFirstInMonth ? (
                                            <div className={`${resolvedDarkMode ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-200'} border px-2 py-0.5 rounded shadow-lg z-20 flex items-center justify-center h-[18px]`}>
                                                <span className={`${resolvedDarkMode ? 'text-slate-200' : 'text-slate-800'} text-[9px] font-black uppercase tracking-tighter leading-none`}>{seg.date}</span>
                                            </div>
                                        ) : (
                                            <div className={`w-1.5 h-1.5 ${resolvedDarkMode ? 'bg-slate-600' : 'bg-slate-300'} rounded-full z-20`} />
                                        )}
                                    </div>
                                    <div className="flex flex-col items-center justify-start gap-1.5 pt-2.5 relative z-10 overflow-visible">
                                        {seg.bottom.map((p, i) => <PaperCard key={i} paper={p} position="bottom" onClick={() => setActiveItem(p)} isDarkMode={resolvedDarkMode} />)}
                                    </div>
                                </div>
                            ))}
                            <div className="h-full w-[20vw] shrink-0" aria-hidden="true"></div>
                        </div>
                        <div className="stacked-view">
                            {flatPapers.map((paper) => (
                                <div key={`${paper.name}-${paper.year}`} className="stacked-item">
                                    <PaperCard paper={paper} position="top" onClick={() => setActiveItem(paper)} isDarkMode={resolvedDarkMode} />
                                </div>
                            ))}
                        </div>
                    </main>

                    <div className="fixed bottom-10 legend-bar w-full z-50">
                        {Object.entries(ACCENTS).map(([k,v]) => (
                            <div key={k} className="flex items-center gap-2.5 cursor-default group opacity-60 hover:opacity-100 transition-opacity">
                                <div className={`w-3.5 h-1 ${v.accent} rounded-[1px] transition-all group-hover:scale-x-150 shadow-[0_0_10px_rgba(255,255,255,0.2)]`} />
                                <span className={`text-[10.5px] font-black uppercase tracking-widest ${resolvedDarkMode ? 'text-slate-300' : 'text-slate-700'}`}>{v.label}</span>
                            </div>
                        ))}
                    </div>

                    <div className="fixed bottom-4 right-6 z-50 pointer-events-none copyright-note">
                        <a href="https://github.com/2-mo" target="_blank" rel="noopener noreferrer" className="pointer-events-auto hover:opacity-80 transition-opacity">
                            {'\u00A9'} {currentYear} @2-mo
                        </a>
                    </div>

                    {activeItem && (
                        <div className="fixed inset-0 z-[100] bg-black/80 backdrop-blur-md flex items-center justify-center p-6 animate-in fade-in duration-300" onClick={() => setActiveItem(null)}>
                            <div className="modal-container w-full max-w-[460px] shadow-2xl rounded-xl overflow-hidden animate-in zoom-in-95 relative" onClick={e => e.stopPropagation()}>
                                <div className="modal-close-trigger" onClick={() => setActiveItem(null)}><Icon name="Close" size={16} /></div>
                                <div className="h-1.5 w-full shadow-sm" style={{ backgroundColor: (ACCENTS[activeItem.type] || ACCENTS.llm).highlight }} />
                                <div className="p-10 relative">
                                    <div className="mb-6">
                                        <div className="flex items-center gap-2 mb-4">
                                            <span className={`px-2.5 py-1 text-[9px] font-black uppercase tracking-widest rounded border ${resolvedDarkMode ? 'bg-slate-800 text-slate-300 border-slate-700' : 'bg-slate-100 text-slate-600 border-slate-200'}`}>{activeItem.conf} // {activeItem.year}</span>
                                            {activeItem.badge && <span className="px-2 py-1 text-[9px] font-black uppercase rounded text-white" style={{ backgroundColor: activeItem.badgeColor || '#801a1a' }}>{activeItem.badge}</span>}
                                        </div>
                                        <h3 className={`text-2xl font-black italic tracking-tighter leading-[1.1] mb-2 ${resolvedDarkMode ? 'text-white' : 'text-slate-900'}`}>{activeItem.title}</h3>
                                        <p className="text-xs font-bold text-slate-400 mb-6 italic">{activeItem.anno}</p>
                                        {activeItem.image && <div className="mt-4 mb-6 rounded-lg overflow-hidden bg-black/20 shadow-inner"><img src={activeItem.image} className="w-full h-auto block" /></div>}
                                    </div>
                                    <div className={`py-6 border-y mb-8 italic text-[13px] text-justify leading-relaxed ${resolvedDarkMode ? 'border-slate-800 text-slate-300' : 'border-slate-100 text-slate-700'}`}>
                                        {activeItem.desc || `This contribution explores the intersection of perception and logic in video anomaly understanding.` }
                                    </div>
                                    <div className="grid grid-cols-2 gap-4">
                                        <a href={activeItem.arxiv || "#"} target="_blank" className={`flex items-center justify-center py-3.5 text-[11px] font-black uppercase tracking-widest transition-all rounded-lg ${resolvedDarkMode ? 'bg-white text-slate-900 hover:bg-slate-200' : 'bg-slate-900 text-white hover:bg-slate-800'}`}>READ ARCHIVE</a>
                                        <a href={activeItem.github || "#"} target="_blank" className={`flex items-center justify-center py-3.5 border-2 text-[11px] font-black uppercase tracking-widest transition-all rounded-lg ${resolvedDarkMode ? 'border-slate-700 text-white hover:bg-slate-800' : 'border-slate-200 text-slate-900 hover:bg-slate-50'}`}>SOURCE CODE</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
